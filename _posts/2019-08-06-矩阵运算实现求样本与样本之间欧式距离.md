---


layout:     post
title:      矩阵运算实现求样本与样本之间欧式距离
subtitle:   欧式距离之矩阵运算
date:       2019-08-06
author:     Nick
header-img: img/博客背景.jpg
catalog: true
tags:
    - 带点数学
---

## 前言

最近需要写关于kmeans的一些小程序，需要计算距离，直接写for循环又特别慢，再要是样本多一点，那简直了。细细一想，需要计算距离的地方还真不少，kmeans、KNN、图等等。

## 1. 理论指导

小学学过的公式，开平方：$(a-b)^2 = a^2+b^2-2ab$，这里无非是转换成其矩阵形式。

假设现在有两个矩阵，分别是A和B，分别包含2个和3个样本，每个样本有三个特征：

![img](/img/2019-08-06-27.png)

![2019-08-06-28](/img/2019-08-06-28.png)

先求ABT:

![IMG](/img/2019-08-06-29.png)

然后分别对A和B中的每个样本求其向量的模平方，也就是每个特征平方求和，最后广播（复制）成2*3的矩阵，与ABT形状一致。

![img](/img/2019-08-06-30.png)

最后：

![img](/img/2019-08-06-31.png)

## 2. python 矩阵计算

```python
import numpy as np
from scipy.spatial.distance import pdist, squareform

def EuclideanDistances(A, B):
    BT = B.transpose()
    vecProd = np.dot(A, BT)
    SqA = A ** 2
    sumSqA = np.matrix(np.sum(SqA, axis=1))
    sumSqAEx = np.tile(sumSqA.transpose(), (1, vecProd.shape[1]))

    SqB = B ** 2
    sumSqB = np.sum(SqB, axis=1)
    sumSqBEx = np.tile(sumSqB, (vecProd.shape[0], 1))

    SqED = sumSqBEx + sumSqAEx - 2 * vecProd
    ED = np.sqrt(SqED)
    return ED

A = np.random.randint(0, 255, (2, 3))

# 自己写的函数
dis = EuclideanDistances(A, A)
print(dis)

# scipy定义的函数
X = pdist(A, 'euclidean') # 这个的结果是仅包含下三角的一维向量，需要用下面的函数展开成二维对称矩阵
Y = squareform(X, force='no', checks=True)
print(Y)

# result：完全一致
[[  0.        143.6279917]
 [143.6279917   0.       ]]
[[  0.        143.6279917]
 [143.6279917   0.       ]]
```

