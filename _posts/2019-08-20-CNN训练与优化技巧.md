---

layout:     post
title:      CNN训练与优化技巧
subtitle:   Bag of Tricks for Image Classification with Convolutional Neural Networks
date:       2019-08-20
author:     Nick
header-img: img/博客背景.jpg
catalog: true
tags:
    - 深度学习
    - Training Tricks
---

**写在前面**

[文章地址](https://arxiv.org/pdf/1812.01187.pdf)

[github上的相关代码](https://github.com/search?q=Bag+of+Tricks+for+Convolutional+Neural+Networks)

## 1. 简介

现有很多网络的进步并非仅仅来自改进的模型架构。训练程序的改进，包括损失函数的变化，数据预处理和优化方法也起了重要作用。在过去几年中已经提出了大量这样的改进，但是受到的关注相对较少。在文献中，大多数只是作为实现细节提及，而其他只能在源代码中找到。

我们通过实验表明，有几个技巧可以显著提高准确性，将它们组合在一起可以进一步提高模型的准确性。我们将应用所有技巧后的ResNet-50与表1中的其他相关网络进行比较，top-1验证准确率从75.3％提高到79.29％，它还优于SE-ResNeXt-50。**此外，我们表明我们的方法可以推广到其他网络和数据集。我们进一步表明，使用我们的技巧训练的模型在其他应用领域（如对象检测和语义分割）中带来了更好的迁移学习性能。**

## 2. 训练过程

### 2.1 训练细节

我们采用ResNet作为我们的baseline。训练和验证之间的预处理流程是不同的。在训练期间，逐个执行以下步骤：

* 随机采样图像并将其解码为[0, 255]中的32位浮点像素值;
* 随机裁剪一块长宽比介于[3/4, 4/3]之间、面积介于[8%,100%]之间的矩形，然后放缩到224x224的正方形；
* 以0.5的概率随机水平翻转；
* 统一放缩色调，饱和度和亮度系数位于[0.6,1.4]之间；
* 加入系数为正态分布N(0,0.1)的PCA噪声；
* 通过减去【123.68,116.779,103.939】并分别除【以58.393,57.12,57.375】来标准化RGB通道。

在验证过程中，将每个图像的较短边调整为256像素，同时保持其纵横比。接下来，我们在中心裁剪出224×224的区域，并将RGB通道标准化，类似于训练过程，在验证期间不执行任何随机扩充。

使用Xavier算法[6]初始化卷积和完全连接层的权重。Nesterov Accelerated Gradient（NAG）下降用于训练。每个模型在8个Nvidia V100 GPU上训练120个epoch，总批量为256。学习率初始化为0.1，并在第30,60和90个时期除以10。

### 2.2 实验结果

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-1.png)

## 3. 高效训练

在本节中，我们将介绍各种能够实现**低精度**和**大批量训练**的技术，而不会牺牲模型的准确性。有些技术甚至可以提高准确性和训练速度。

### 3.1 大批量训练

小批量SGD将多个样本分组到一个小批量，以增加并行性。但是，**使用大批量大小可能会减慢训练进度**。换句话说，对于相同数量的epoch，具有大批量大小的训练导致与使用较小批量大小训练的模型相比具有降低的验证准确度。多项工作提出了启发式方法来解决这个问题。在以下段落中，我们将研究四种启发式方法，这些方法有助于扩展单机训练的批量大小。

#### 3.1.1 线性缩放学习率

在小批量SGD中，梯度下降是随机过程，因为在每个批次中随机选择样本。增加批量大小不会改变随机梯度的期望，但会降低其方差。换句话说，**大批量大小会降低噪声，因此我们可以提高学习速率**，以便在梯度方向的相反方向上取得更大的进展。Goyal等人随着批量大小的线性增加学习率，经验性地用于ResNet-50培训。特别是，如果**我们遵循He等人选择`0.1`作为批量大小256的初始学习率，然后当更改为更大的批量大小b时，我们将初始学习率提高到`0.1 × b/256`。**

#### 3.1.2 学习率热身

在训练开始时，所有参数通常都是随机值，因此离最终结果较远。使用太大的学习率可能导致数值不稳定。**在热身启发式中，我们在开始时使用较小的学习率，然后在训练过程稳定时切换回初始学习率[9]**。Goyal等人提出了一种渐进的热身策略，将学习率从0线性地提高到初始学习率。换句话说，假设我们将使用最初的m个批次（例如5个epoch）进行热身，并且初始学习速率为`η`，然后在批次i，`1 ≤ i ≤ m`，我们将学习速率设置为`iη/m`。

#### 3.1.3 零γ

ResNet网络由多个残差块组成，每个块由几个卷积层组成。给定输入x，假设(x)是块中最后一层的输出，则该残差块然后输出x+(x)。请注意，块的最后一层可以是批量标准化（BN）层。BN层首先标准化其输入，由x^表示，然后执行比例变换γx^ + β。γ和β都是可学习的参数，其元素分别初始化为1和0。**在零γ初始化启发式中，我们为位于残差块末尾的所有BN层初始化γ = 0。因此，所有残差块只返回其输入，模拟具有较少层数的网络，并且在初始阶段更容易训练。**

#### 3.1.4 无bias衰减

权重衰减通常应用于所有可学习的参数，包括权重和bias。它相当于对所有参数应用L2正则化以将其值逼近0。正如贾等人所指出的那样，但是，**建议仅将正则化应用于权重以避免过度拟合**。无bias衰减启发式遵循此建议，它仅将权重衰减应用于卷积和完全连接的层中的权重。其他参数，包括BN层中的偏差和γ和β，都剩下，不使用正则化。

### 3.2 低精度训练

神经网络通常采用32位浮点（FP32）精度进行训练。也就是说，所有数字都以FP32格式存储，算术运算的输入和输出也都是FP32数字。但是，新硬件可能具有增强的算术逻辑单元，用于较低精度的数据类型。例如，前面提到的Nvidia V100在FP32中提供14 TFLOPS，在FP16中提供超过100 TFLOPS。如表3所示，在V100上从FP32切换到FP16后，整体训练速度加快了2到3倍。

### 3.3 实验结果

![2019-08-20-3](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-3.png)

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-2.png)

## 4. 模型改进

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-4.png)

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-5.png)

## 5. 训练改进

### 5.1 余弦学习率衰减

学习率调整对训练至关重要。在3.1节描述的学习率热身之后，我们通常会从初始学习率稳步降低学习率。广泛使用的策略以指数方式衰减学习率。He等人每30个时期降低0.1的，我们称之为“逐步衰减”。Szegedy等人每两个epoch的降幅为0.94。

与之相反，Loshchilov等人提出余弦退火策略。简化版本通过遵循余弦函数将学习速率从初始值降低到0。假设批次总数为T（忽略预热阶段），然后在批次t，学习率ηt计算如下：

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-6.png)

其中η是初始学习率。我们将此调整称为“余弦”衰减。

逐步衰减和余弦衰减之间的比较如图所示。可以看出，余弦衰减在开始时缓慢地降低了学习速率，然后在中间变得几乎线性减小，并且在结束时再次减慢。与逐步衰减相比，余弦衰减从一开始就开始衰减学习，但仍然很大，直到逐步衰减将学习率降低10倍，这可能会改善训练进度。

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-7.png)

### 5.2 标签平滑

Label Smoothing策略最早被提出用于训练Inception-v2网络结构，one-hot这种脉冲式的标签容易导致过拟合，因此它修改ground truth的概率分布如下，

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-8.png)

其中，ϵ表示很小的常数，为超参数，K表示分类任务中目标类别的个数。

### 5.3  知识蒸馏

在知识蒸馏中，我们使用教师模型来帮助训练当前模型，这被称为学生模型。教师模型通常是具有更高准确度的预训练模型，因此通过模仿，学生模型能够在保持模型复杂性相同的同时提高其自身的准确性。一个例子是使用ResNet-152作为教师模型来帮助培训ResNet-50。

在训练期间，我们添加蒸馏损失来惩罚教师模型的softmax输出与学习模型之间的差异。假设p是真实概率分布，并且z和r分别是学生模型和教师模型的最后完全连接层的输出，其中T是超参数：

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-9.png)

### 5.4 Mixup Training

在2.1节中，我们描述了在训练之前如何增强图像。这里我们考虑另一种名为mixup的增强方法。在mixup中，每次我们随机抽样两个例子(xi, yi) 和(xj, yj)。然后我们通过这两个例子的加权线性插值形成一个新的样本：

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-10.png)

λ ∈ [0, 1]，训练时我们仅使用新样本。

### 5.5 实验结果

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-11.png)

## 6. 迁移学习

### 6.1 目标检测

**pass**

### 6.2 语义分割

语义分割根据输入图像预测每个像素的类别。我们使用完全卷积网络（FCN）来完成这项任务，并在ADE20K数据集上训练模型。遵循PSPNet [31]和Zhang等人，我们用前面部分讨论的各种预训练模型替换基础网络，并在阶段3和阶段4应用扩张卷积策略。解码器建立在基础网络之上，以进行最终预测。

表9中报告了像素精度（pixAcc）和平均交叉度（mIoU）。与我们在物体检测上的结果相矛盾，余弦学习速率表有效地提高了FCN性能的准确性，而其他改进则提供了不理想的结果。对该现象的潜在解释是语义分割在像素级别中预测。虽然使用标签平滑，蒸馏和混合培训的模型有利于软化标签，但模糊的像素级信息可能会模糊并降低整体像素级精度。

![img](C:\Users\CV\Documents\GitHub\niecongchong.github.io\img\2019-08-20-12.png)









## 1. 数据预处理



## 2. 模型结构



## 3. 损失函数



## 4. 优化器



## 5. 学习率



## 6. 硬件环境